obh = temp_sxts
obj = temp_sxts
coords <- attr(obj, "coordinates")
attributes(obj)
attributes.sxts(obj)
coords <- attr(obj, "coords")
projection <- attr(obj, "projection")
temp_matrix <- cbind(coords, t(coredata(obj)))
new_raster <- raster::rasterFromXYZ(temp_matrix)
projection(new_raster) <- projection
new_raster <- raster::setZ(new_raster, as.character(dates))
names(new_raster) <- as.character(dates)
# Add a sxts to raster method
rasterFromSxts.sxts <- function(obj, ...){
coords <- attr(obj, "coords")
projection <- attr(obj, "projection")
temp_matrix <- cbind(coords, t(coredata(obj)))
new_raster <- raster::rasterFromXYZ(temp_matrix)
projection(new_raster) <- projection
new_raster <- raster::setZ(new_raster, as.character(dates))
names(new_raster) <- as.character(dates)
return(new_raster)
}
temp_raster <- rasterFromSxts.sxts(temp_sxts)
library(ncdf4)
data <-
nc_data = ncdf4::nc_open(filename = filename)
nc_data = ncdf4::nc_open(filename = filename)
library(anyFit)
names(nc_data)
names(nc_data$dim)
names(nc_data$dim)
names(nc_data$var)
data <- nc2xts(filename = filename, varname = varname)
var_names = names(nc_data$dim)
time_var = NULL
for (var in var_names) {
attr_units = ncdf4::ncatt_get(nc_data, var, "units")$value
if (!is.null(attr_units) && grepl("since", attr_units)) {
time_var = var
base_date = as.POSIXct(sub(".*since ", "", attr_units), tz = "UTC")
base_time = sub(" since.*", "", attr_units)
break
}
}
# Display the identified time variable
# print(paste0("Time variable name is:", time_var))
raw_dates = ncdf4::ncvar_get(nc_data, time_var)
dates = base_date + do.call(base_time, list(raw_dates))
nc2xts = function (filename, varname, shapefile = NA, country = NA, continent = NA) {
nc_data = ncdf4::nc_open(filename = filename)
nc_brick = raster::brick(filename, varname = varname, level = 1)
if (!is.na(country)) {
countries = world_data$name
if (country %in% countries) {
mask = subset(world_data, name == country)
r2 <- raster::crop(nc_brick, raster::extent(mask))
r3 <- raster::mask(r2, mask = mask)
}
else {
stop("Country name is incorrect")
}
}
else if (!is.na(continent)) {
continents = world_data$continent
if (continent %in% continents) {
mask = subset(world_data, continent == continent)
r2 <- raster::crop(nc_brick, raster::extent(mask))
r3 <- raster::mask(r2, mask = mask)
}
else {
stop("Continent name is incorrect")
}
}
else if (!is.na(shapefile)) {
mask = raster::shapefile(shapefile)
r2 <- raster::crop(nc_brick, raster::extent(mask))
r3 <- raster::mask(r2, mask = mask)
}
else {
r3 = nc_brick
}
t = raster::rasterToPoints(r3)
tt = t(t)
coords = t(tt[c(1, 2), ])
tt = tt[-c(1, 2), ]
var_names = names(nc_data$dim)
time_var = NULL
for (var in var_names) {
attr_units = ncdf4::ncatt_get(nc_data, var, "units")$value
if (!is.null(attr_units) && grepl("since", attr_units)) {
time_var = var
base_date = as.POSIXct(sub(".*since ", "", attr_units), tz = "UTC")
base_time = sub(" since.*", "", attr_units)
break
}
}
# Display the identified time variable
# print(paste0("Time variable name is:", time_var))
raw_dates = ncdf4::ncvar_get(nc_data, time_var)
dates = base_date + do.call(base_time, list(raw_dates))
r4 = raster::setZ(r3, as.character(dates))
names(r4) = as.character(dates)
ncdf_sxts <- sxts(data = tt, order.by = dates, coords = coords, projection = raster::projection(r4))
list_out = list(raster = r4, ncdf_sxts = ncdf_sxts)
return(list_out)
}
data <- nc2xts(filename = filename, varname = varname)
data_sxts <- data$ncdf_sxts
period = "months"
new_raster * 1000
new_raster * 1000
new_raster * 100000
min(obj)
diff(index(obj))
unique(diff(index(obj)))
length(diff(index(obj)))
length(unique(diff(index(obj))))
# Custom summary method for 'sxts'
summary.sxts <- function(obj, ...) {
cat("Summary of sxts obj:\n")
cat("Number of elements:", ncol(obj), "\n")
cat("Number of dates:", nrow(obj), "\n")
if (length(unique(diff(index(obj)))) == 1) {
cat("Time step is:",  "Strict", "\n")
cat("Time step is:",   diff(index(obj))[1] , "\n")
} else{
cat("Time step is:",  "Variable", "\n")
cat("Min time step is:",   min(diff(index(obj))) , "\n")
cat("Max time step is:",   max(diff(index(obj))) , "\n")
}
cat("Number of dates:", nrow(obj), "\n")
cat("Spatial projection:", attr(obj, "projection"), "\n")
cat("Range of dates is from:", as.character(min(index(obj))), "to:",  as.character(max(index(obj))), "\n")
cat("Min value is:", min(obj),  "\n")
cat("Max value is:", max(obj),  "\n")
# NextMethod("summary")  # Call the default summary method for xts
}
summary(obj)
a=diff(index(obj))
a
name(a)
names(a)
min(diff(index(obj)))
as.numeric(time_diff[1], units = "hours")
time_diff <- diff(index(obj))
as.numeric(time_diff[1], units = "hours")
as.numeric(time_diff[1], units = "mins")
# Custom summary method for 'sxts'
summary.sxts <- function(obj, ...) {
cat("Summary of sxts obj:\n")
cat("Number of elements:", ncol(obj), "\n")
cat("Number of dates:", nrow(obj), "\n")
time_diff <- diff(index(obj))
if (length(unique(time_diff)) == 1) {
cat("Time step is:",  "Strict", "\n")
cat("Time step is:",   as.numeric(time_diff[1], units = "hours") , "hours",  "\n")
} else{
cat("Time step is:",  "Variable", "\n")
cat("Min time step is:",  as.numeric(min(time_diff[1]), units = "hours") , "hours", "\n")
cat("Max time step is:",  as.numeric(max(time_diff[1]), units = "hours") , "hours", "\n")
}
cat("Number of dates:", nrow(obj), "\n")
cat("Spatial projection:", attr(obj, "projection"), "\n")
cat("Range of dates is from:", as.character(min(index(obj))), "to:",  as.character(max(index(obj))), "\n")
cat("Min value is:", min(obj),  "\n")
cat("Max value is:", max(obj),  "\n")
# NextMethod("summary")  # Call the default summary method for xts
}
summary(obj)
summary(new_raster)
View(coords)
attr(obj, "coords")$x
attr(obj, "coords")[.1]
attr(obj, "coords")[,1]
# Custom summary method for 'sxts'
summary.sxts <- function(obj, ...) {
cat("Summary of sxts object:\n")
cat("Number of elements:", ncol(obj), "\n")
cat("Number of dates:", nrow(obj), "\n")
cat("Range of dates is from:", as.character(min(index(obj))), "to:",  as.character(max(index(obj))), "\n")
time_diff <- diff(index(obj))
if (length(unique(time_diff)) == 1) {
cat("Time step is:",  "Strict", "\n")
cat("Time step is:",   as.numeric(time_diff[1], units = "hours") , "hours",  "\n")
} else{
cat("Time step is:",  "Variable", "\n")
cat("Min time step is:",  as.numeric(min(time_diff[1]), units = "hours") , "hours", "\n")
cat("Max time step is:",  as.numeric(max(time_diff[1]), units = "hours") , "hours", "\n")
}
cat("Number of dates:", nrow(obj), "\n")
cat("Spatial projection:", attr(obj, "projection"), "\n")
cat("Spatial extent is:", min(attr(obj, "coords")[,1]), max(attr(obj, "coords")[,1]),
min(attr(obj, "coords")[,2]), max(attr(obj, "coords")[,2]), " (xmin, xmax, ymin, ymax)", "\n")
cat("Min value is:", min(obj),  "\n")
cat("Max value is:", max(obj),  "\n")
# NextMethod("summary")  # Call the default summary method for xts
}
summary(new_raster)
summary(obj)
# Custom summary method for 'sxts'
summary.sxts <- function(obj, ...) {
cat("Summary of sxts object:\n")
cat("Number of elements:", ncol(obj), "\n")
cat("Number of dates:", nrow(obj), "\n")
cat("Range of dates is from:", as.character(min(index(obj))), "to:",  as.character(max(index(obj))), "\n")
time_diff <- diff(index(obj))
if (length(unique(time_diff)) == 1) {
cat("Time step is:",  "Strict", "\n")
cat("Time step is:",   as.numeric(time_diff[1], units = "hours") , "hours",  "\n")
} else{
cat("Time step is:",  "Variable", "\n")
cat("Min time step is:",  as.numeric(min(time_diff[1]), units = "hours") , "hours", "\n")
cat("Max time step is:",  as.numeric(max(time_diff[1]), units = "hours") , "hours", "\n")
}
cat("Number of dates:", nrow(obj), "\n")
cat("Spatial projection:", attr(obj, "projection"), "\n")
cat("Spatial extent is:", min(attr(obj, "coords")[,1]), ",", max(attr(obj, "coords")[,1]), ",",
min(attr(obj, "coords")[,2]), ",", max(attr(obj, "coords")[,2]), " (xmin, xmax, ymin, ymax)", "\n")
cat("Min value is:", min(obj),  "\n")
cat("Max value is:", max(obj),  "\n")
# NextMethod("summary")  # Call the default summary method for xts
}
summary(obj)
#' @export
period_apply_nc = function (data, filename = NA, varname = NA, period = "months",
period_multiplier = 1, FUN = "mean", ...){
if (!is.na(filename)) {
temp = nc2xts(filename = filename, varname = varname,
...)
ncdf_sxts = temp$ncdf_sxts
}
else if ("raster" %in% class(data)){
ncdf_sxts <- rasterFromSxts.sxts(data)
}
spec_period <- endpoints(ncdf_xts, on = period, k = period_multiplier)
ncdf_stats = lapply(1:ncol(ncdf_xts), FUN = function(x) {
period.apply(ncdf_xts[, x], spec_period, FUN = FUN)
})
ncdf_stats = t(do.call(cbind, ncdf_stats))
ncdf_stats = cbind(coords, ncdf_stats)
raster_fun = raster::rasterFromXYZ(ncdf_stats)
projection(raster_fun) = raster::projection(raster_file)
return(ncdf_stats)
}
data_agg <- period_apply_nc(data_sxts, period = "days", period_multiplier = 3)
#' @export
period_apply_nc = function (data, filename = NA, varname = NA, period = "months",
period_multiplier = 1, FUN = "mean", ...){
if (!is.na(filename)) {
temp = nc2xts(filename = filename, varname = varname,
...)
ncdf_sxts = temp$ncdf_sxts
}
else if ("raster" %in% class(data)){
ncdf_sxts <- rasterFromSxts.sxts(data)
}
spec_period <- endpoints(ncdf_sxts, on = period, k = period_multiplier)
ncdf_stats = lapply(1:ncol(ncdf_sxts), FUN = function(x) {
period.apply(ncdf_sxts[, x], spec_period, FUN = FUN)
})
ncdf_stats = t(do.call(cbind, ncdf_stats))
ncdf_stats = cbind(coords, ncdf_stats)
raster_fun = raster::rasterFromXYZ(ncdf_stats)
projection(raster_fun) = raster::projection(raster_file)
return(ncdf_stats)
}
data_agg <- period_apply_nc(data_sxts, period = "days", period_multiplier = 3)
#' @export
period_apply_nc = function (data, filename = NA, varname = NA, period = "months",
period_multiplier = 1, FUN = "mean", ...){
if (!is.na(filename)) {
temp = nc2xts(filename = filename, varname = varname,
...)
ncdf_sxts = temp$ncdf_sxts
}
else if ("raster" %in% class(data)){
ncdf_sxts <- rasterFromSxts.sxts(data)
} else {
ncdf_sxts <- data
}
spec_period <- endpoints(ncdf_sxts, on = period, k = period_multiplier)
ncdf_stats = lapply(1:ncol(ncdf_sxts), FUN = function(x) {
period.apply(ncdf_sxts[, x], spec_period, FUN = FUN)
})
ncdf_stats = t(do.call(cbind, ncdf_stats))
ncdf_stats = cbind(coords, ncdf_stats)
raster_fun = raster::rasterFromXYZ(ncdf_stats)
projection(raster_fun) = raster::projection(raster_file)
return(ncdf_stats)
}
data_agg <- period_apply_nc(data_sxts, period = "days", period_multiplier = 3)
start_time <- Sys.time()
data_agg <- period_apply_nc(data_sxts, period = "days", period_multiplier = 3)
#' @export
period_apply_nc = function (data, filename = NA, varname = NA, period = "months",
period_multiplier = 1, FUN = "mean", ...){
if (!is.na(filename)) {
temp = nc2xts(filename = filename, varname = varname,
...)
ncdf_sxts = temp$ncdf_sxts
}
else if ("raster" %in% class(data)){
ncdf_sxts <- rasterFromSxts.sxts(data)
} else {
ncdf_sxts <- data
}
spec_period <- endpoints(ncdf_sxts, on = period, k = period_multiplier)
ncdf_stats = lapply(1:ncol(ncdf_sxts), FUN = function(x) {
period.apply(ncdf_sxts[, x], spec_period, FUN = FUN)
})
ncdf_stats = t(do.call(cbind, ncdf_stats))
ncdf_stats = cbind(coords, ncdf_stats)
raster_fun = raster::rasterFromXYZ(ncdf_stats)
# projection(raster_fun) = raster::projection(raster_file)
return(ncdf_stats)
}
start_time <- Sys.time()
data_agg <- period_apply_nc(data_sxts, period = "days", period_multiplier = 3)
time_end = Sys.time()
print(time_end - start_time)
#' @export
period_apply_nc = function (data, filename = NA, varname = NA, period = "months",
period_multiplier = 1, FUN = "mean", ...){
if (!is.na(filename)) {
temp = nc2xts(filename = filename, varname = varname,
...)
ncdf_sxts = temp$ncdf_sxts
}
else if ("raster" %in% class(data)){
ncdf_sxts <- rasterFromSxts.sxts(data)
} else {
ncdf_sxts <- data
}
spec_period <- endpoints(ncdf_sxts, on = period, k = period_multiplier)
ncdf_stats = lapply(1:ncol(ncdf_sxts), FUN = function(x) {
period.apply(ncdf_sxts[, x], spec_period, FUN = FUN)
})
ncdf_stats = t(do.call(cbind, ncdf_stats))
ncdf_stats = cbind(coords, ncdf_stats)
# raster_fun = raster::rasterFromXYZ(ncdf_stats)
# projection(raster_fun) = raster::projection(raster_file)
return(ncdf_stats)
}
start_time <- Sys.time()
data_agg <- period_apply_nc(data_sxts, period = "days", period_multiplier = 3)
time_end = Sys.time()
print(time_end - start_time)
View(data_agg)
#' @export
period_apply_nc = function (data, filename = NA, varname = NA, period = "months",
period_multiplier = 1, FUN = "mean", ...){
if (!is.na(filename)) {
temp = nc2xts(filename = filename, varname = varname,
...)
ncdf_sxts = temp$ncdf_sxts
}
else if ("raster" %in% class(data)){
ncdf_sxts <- rasterFromSxts.sxts(data)
} else {
ncdf_sxts <- data
}
spec_period <- endpoints(ncdf_sxts, on = period, k = period_multiplier)
ncdf_stats = lapply(1:ncol(ncdf_sxts), FUN = function(x) {
period.apply(ncdf_sxts[, x], spec_period, FUN = FUN)
})
ncdf_stats = do.call(cbind, ncdf_stats)
# ncdf_stats = cbind(coords, ncdf_stats)
# raster_fun = raster::rasterFromXYZ(ncdf_stats)
# projection(raster_fun) = raster::projection(raster_file)
return(ncdf_stats)
}
start_time <- Sys.time()
data_agg <- period_apply_nc(data_sxts, period = "days", period_multiplier = 3)
time_end = Sys.time()
print(time_end - start_time)
class(data_agg)
class(temp_sxts)
# sxts constructor
sxts <- function(data, order.by, coords = NULL, projection = NULL) {
obj <- xts(data, order.by)  # Create an xts obj
class(obj) <- c("sxts", class(obj))  # Set the class to inherit from xts
attr(obj, "description") <- "This is a sxts object"
attr(obj, "elements") <- ncol(obj)  # Add an 'elements' attribute
attr(obj, "coords") <- coords  # Add a 'coords' attribute
attr(obj, "projection") <- projection  # Add a 'projection' attribute
return(obj)
}
data <- nc2xts(filename = filename, varname = varname)
data_sxts <- data$ncdf_sxts
time.range <- sub("/", " / ", .makeISO8601(obj), fixed = TRUE)
time.range <- sub("/", " / ", makeISO8601(obj), fixed = TRUE)
.makeISO8601 <- function(x) {
paste(start(x), end(x), sep = "/")
}
time.range <- sub("/", " / ", makeISO8601(obj), fixed = TRUE)
time.range <- sub("/", " / ", .makeISO8601(obj), fixed = TRUE)
time.range
print.sxts <- function(object){
is.data.empty <- is.null(dim(object)) || sum(dim(object)) == 0
is.zero.index <- (length(.index(object)) == 0)
nr <- NROW(object)
nc <- ifelse(is.data.empty, 0, NCOL(object))
# "zero-length" xts
#    * index length == 0, but tclass and tzone are set
#    * NROW == 0
#    * NCOL >  0 and may have column names
# examples:
#   str(.xts(1, 1)["1900"])
#   str(.xts(cbind(a = 1, b = 2), 1)["1900"])
is.zero.length <- (is.zero.index && nr == 0 && !is.data.empty)
# "zero-width" xts
#    * index length > 0
#    * NROW == 0
#    * NCOL == 0
# example:
#   str(.xts(, 1:5))
is.zero.width <- (!is.zero.index && is.data.empty)
# "empty" xts
#    * index length == 0, but tclass and tzone are set
#    * NROW == 0
#    * NCOL == 0
# example:
#   str(.xts(, numeric(0)))
#   str(.xts(matrix()[0,0], numeric(0)))
is.empty <- (is.zero.index && is.data.empty)
if (is.empty) {
header <- "An empty sxts object"
} else if (is.zero.length) {
header <- "A zero-length sxts object"
} else {
# zero-width and regular xts objects
if (is.zero.width) {
header <- "A zero-width sxts object on"
} else {
header <- "An sxts object on"
}
time.range <- sub("/", " / ", .makeISO8601(object), fixed = TRUE)
header <- paste(header, time.range)
}
cat(header, "\n")
}
print.sxts(temp_sxts)
a <- temp_sxts
str.sxts <- function(object){
is.data.empty <- is.null(dim(object)) || sum(dim(object)) == 0
is.zero.index <- (length(.index(object)) == 0)
nr <- NROW(object)
nc <- ifelse(is.data.empty, 0, NCOL(object))
# "zero-length" xts
#    * index length == 0, but tclass and tzone are set
#    * NROW == 0
#    * NCOL >  0 and may have column names
# examples:
#   str(.xts(1, 1)["1900"])
#   str(.xts(cbind(a = 1, b = 2), 1)["1900"])
is.zero.length <- (is.zero.index && nr == 0 && !is.data.empty)
# "zero-width" xts
#    * index length > 0
#    * NROW == 0
#    * NCOL == 0
# example:
#   str(.xts(, 1:5))
is.zero.width <- (!is.zero.index && is.data.empty)
# "empty" xts
#    * index length == 0, but tclass and tzone are set
#    * NROW == 0
#    * NCOL == 0
# example:
#   str(.xts(, numeric(0)))
#   str(.xts(matrix()[0,0], numeric(0)))
is.empty <- (is.zero.index && is.data.empty)
if (is.empty) {
header <- "An empty sxts object"
} else if (is.zero.length) {
header <- "A zero-length sxts object"
} else {
# zero-width and regular xts objects
if (is.zero.width) {
header <- "A zero-width sxts object on"
} else {
header <- "An sxts object on"
}
time.range <- sub("/", " / ", .makeISO8601(object), fixed = TRUE)
header <- paste(header, time.range)
}
cat(header, "\n")
}
a <- temp_sxts
ab <- temp_sxts
# sxts constructor
sxts <- function(data, order.by, coords = NULL, projection = NULL) {
obj <- xts(data, order.by)  # Create an xts obj
class(obj) <- c("sxts", class(obj))  # Set the class to inherit from xts
attr(obj, "description") <- "This is a sxts object"
attr(obj, "name") <- "poutses"
attr(obj, "elements") <- ncol(obj)  # Add an 'elements' attribute
attr(obj, "coords") <- coords  # Add a 'coords' attribute
attr(obj, "projection") <- projection  # Add a 'projection' attribute
return(obj)
}
data <- nc2xts(filename = filename, varname = varname)
data_sxts <- data$ncdf_sxts
View(data_agg)
class(data_agg)
ncdf_sxts = temp_sxts
period = "days"
period_multiplier = 3
spec_period <- endpoints(ncdf_sxts, on = period, k = period_multiplier)
FUN = "mean"
a=period.apply(ncdf_sxts[, 1], spec_period, FUN = FUN)
class(a)
